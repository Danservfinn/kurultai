"""
Capability-Based Access Control (CBAC) registry for Kurultai.

This module manages learned capabilities in Neo4j with time-based access
control, enabling secure capability acquisition and authorization.
"""

from datetime import datetime, timedelta
from typing import Dict, List, Optional
import hashlib


class CapabilityRegistry:
    """
    Neo4j-backed registry for learned capabilities with CBAC.

    Manages:
    - LearnedCapability nodes with metadata and code hashes
    - HAS_CAPABILITY relationships with expiry timestamps
    - Capability dependencies and prerequisites
    - Agent authorization checks
    """

    def __init__(self, memory=None):
        """
        Initialize the capability registry.

        Args:
            memory: OperationalMemory instance with execute_query method.
                    If None, registry operates in offline mode (no persistence).
        """
        self.memory = memory
        if self.memory is not None:
            self._ensure_schema()

    def _ensure_schema(self) -> None:
        """Create necessary indexes and constraints."""
        # Unique constraint on capability name
        self.memory.execute_query("""
            CREATE CONSTRAINT capability_name_unique IF NOT EXISTS
            FOR (c:LearnedCapability)
            REQUIRE c.name IS UNIQUE
        """)

        # Index on category for faster filtering
        self.memory.execute_query("""
            CREATE INDEX capability_category IF NOT EXISTS
            FOR (c:LearnedCapability)
            ON (c.category)
        """)

        # Index on agent_id for access checks
        self.memory.execute_query("""
            CREATE INDEX agent_capabilities IF NOT EXISTS
            FOR ()-[r:HAS_CAPABILITY]->()
            ON (r.agent_id)
        """)

    def register(
        self,
        name: str,
        description: str,
        category: str,
        code_hash: str,
        learned_by: str,
        required_capabilities: Optional[List[str]] = None
    ) -> str:
        """
        Register a new learned capability in Neo4j.

        Args:
            name: Unique capability identifier (e.g., "parse_api_integration")
            description: Human-readable description
            category: Capability category (api_integration, data_processing, etc.)
            code_hash: SHA-256 hash of the capability code
            learned_by: Agent ID that learned this capability
            required_capabilities: Optional list of prerequisite capability names

        Returns:
            Capability ID (UUID generated by Neo4j)

        Raises:
            Exception: If capability name already exists
        """
        query = """
        CREATE (c:LearnedCapability {
            name: $name,
            description: $description,
            category: $category,
            code_hash: $code_hash,
            learned_by: $learned_by,
            learned_at: datetime(),
            version: 1,
            status: 'active'
        })
        RETURN elementId(c) AS capability_id
        """

        result = self.memory.execute_query(
            query,
            {
                "name": name,
                "description": description,
                "category": category,
                "code_hash": code_hash,
                "learned_by": learned_by
            }
        )

        if not result:
            raise ValueError(f"Failed to register capability: {name}")

        capability_id = result[0]["capability_id"]

        # Create dependency relationships if specified
        if required_capabilities:
            self._create_dependencies(name, required_capabilities)

        return capability_id

    def _create_dependencies(
        self,
        capability_name: str,
        required_capabilities: List[str]
    ) -> None:
        """Create REQUIRES relationships for capability dependencies."""
        query = """
        MATCH (c:LearnedCapability {name: $capability_name})
        UNWIND $required_capabilities AS req_name
        MATCH (req:LearnedCapability {name: req_name})
        MERGE (c)-[:REQUIRES]->(req)
        """

        self.memory.execute_query(
            query,
            {
                "capability_name": capability_name,
                "required_capabilities": required_capabilities
            }
        )

    def can_execute(self, agent_id: str, capability_name: str) -> bool:
        """
        Check if an agent is authorized to execute a capability.

        Args:
            agent_id: Agent identifier
            capability_name: Capability to check

        Returns:
            True if agent has valid (non-expired) access
        """
        query = """
        MATCH (c:LearnedCapability {name: $capability_name})
        OPTIONAL MATCH (c)<-[r:HAS_CAPABILITY {agent_id: $agent_id}]-()
        WITH c, r,
             r.expires_at AS expires,
             datetime() AS now
        WHERE r IS NOT NULL
          AND (expires IS NULL OR expires > now)
        RETURN count(*) > 0 AS has_access
        """

        result = self.memory.execute_query(
            query,
            {"agent_id": agent_id, "capability_name": capability_name}
        )

        return result[0]["has_access"] if result else False

    def grant(
        self,
        agent_id: str,
        capability_name: str,
        expires_days: int = 90
    ) -> bool:
        """
        Grant capability access to an agent with time-based expiry.

        Args:
            agent_id: Agent to grant access to
            capability_name: Capability to grant
            expires_days: Days until access expires (default: 90)

        Returns:
            True if grant succeeded

        Raises:
            ValueError: If capability does not exist
        """
        # First verify capability exists
        capability = self.get_capability(capability_name)
        if not capability:
            raise ValueError(f"Capability not found: {capability_name}")

        # Calculate expiry timestamp
        expires_at = datetime.utcnow() + timedelta(days=expires_days)

        query = """
        MATCH (c:LearnedCapability {name: $capability_name})
        MERGE (a:Agent {agent_id: $agent_id})
        MERGE (a)-[r:HAS_CAPABILITY]->(c)
        SET r.agent_id = $agent_id,
            r.granted_at = datetime(),
            r.expires_at = datetime($expires_at)
        RETURN count(*) > 0 AS granted
        """

        result = self.memory.execute_query(
            query,
            {
                "agent_id": agent_id,
                "capability_name": capability_name,
                "expires_at": expires_at.isoformat()
            }
        )

        return result[0]["granted"] if result else False

    def revoke(self, agent_id: str, capability_name: str) -> bool:
        """
        Revoke capability access from an agent.

        Args:
            agent_id: Agent to revoke access from
            capability_name: Capability to revoke

        Returns:
            True if relationship was deleted
        """
        query = """
        MATCH (a:Agent {agent_id: $agent_id})
              -[r:HAS_CAPABILITY]->
              (c:LearnedCapability {name: $capability_name})
        DELETE r
        RETURN count(*) AS revoked_count
        """

        result = self.memory.execute_query(
            query,
            {"agent_id": agent_id, "capability_name": capability_name}
        )

        return result[0]["revoked_count"] > 0 if result else False

    def list_capabilities(
        self,
        agent_id: Optional[str] = None
    ) -> List[Dict[str, any]]:
        """
        List all capabilities, optionally filtered by agent access.

        Args:
            agent_id: If provided, filter to capabilities this agent can access

        Returns:
            List of capability dictionaries with metadata
        """
        if agent_id:
            query = """
            MATCH (a:Agent {agent_id: $agent_id})
                  -[r:HAS_CAPABILITY]->
                  (c:LearnedCapability)
            WHERE r.expires_at IS NULL OR r.expires_at > datetime()
            RETURN c.name AS name,
                   c.description AS description,
                   c.category AS category,
                   c.learned_by AS learned_by,
                   c.learned_at AS learned_at,
                   c.version AS version,
                   c.status AS status,
                   r.granted_at AS granted_at,
                   r.expires_at AS expires_at
            ORDER BY c.learned_at DESC
            """
            params = {"agent_id": agent_id}
        else:
            query = """
            MATCH (c:LearnedCapability)
            RETURN c.name AS name,
                   c.description AS description,
                   c.category AS category,
                   c.learned_by AS learned_by,
                   c.learned_at AS learned_at,
                   c.version AS version,
                   c.status AS status,
                   null AS granted_at,
                   null AS expires_at
            ORDER BY c.learned_at DESC
            """
            params = {}

        result = self.memory.execute_query(query, params)

        return [dict(record) for record in result] if result else []

    def get_capability(self, name: str) -> Optional[Dict[str, any]]:
        """
        Get full details for a specific capability.

        Args:
            name: Capability name

        Returns:
            Capability dictionary or None if not found
        """
        query = """
        MATCH (c:LearnedCapability {name: $name})
        OPTIONAL MATCH (c)-[:REQUIRES]->(req:LearnedCapability)
        RETURN c.name AS name,
               c.description AS description,
               c.category AS category,
               c.code_hash AS code_hash,
               c.learned_by AS learned_by,
               c.learned_at AS learned_at,
               c.version AS version,
               c.status AS status,
               collect(DISTINCT req.name) AS required_capabilities
        """

        result = self.memory.execute_query(query, {"name": name})

        if result:
            capability = dict(result[0])
            # Filter out null values from required_capabilities
            capability["required_capabilities"] = [
                r for r in capability.get("required_capabilities", [])
                if r is not None
            ]
            return capability

        return None

    def update_status(self, name: str, status: str) -> bool:
        """
        Update capability status (active, deprecated, disabled).

        Args:
            name: Capability name
            status: New status value

        Returns:
            True if update succeeded
        """
        valid_statuses = {"active", "deprecated", "disabled"}
        if status not in valid_statuses:
            raise ValueError(
                f"Invalid status: {status}. Must be one of {valid_statuses}"
            )

        query = """
        MATCH (c:LearnedCapability {name: $name})
        SET c.status = $status,
            c.updated_at = datetime()
        RETURN count(*) > 0 AS updated
        """

        result = self.memory.execute_query(
            query,
            {"name": name, "status": status}
        )

        return result[0]["updated"] if result else False

    @staticmethod
    def hash_code(code: str) -> str:
        """
        Generate SHA-256 hash of capability code.

        Args:
            code: Python source code

        Returns:
            Hexadecimal hash string
        """
        return hashlib.sha256(code.encode("utf-8")).hexdigest()
